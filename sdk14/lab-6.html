<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-2">
<link rel="stylesheet" type="text/css" href="style.css">
<title>Programowanie rozproszone w Javie - technologia RMI</title>
</head>


<body>

         
<h1>RMI - æwiczenie szóste</h1>
       
<h2><i>Notification Server</i> - samodzielna implementacja aplikacji</h2>

<p>Celem zadania jest stworzenie w technologii rozproszonej RMI serwera,
który zbiera i magazynuje nap³ywaj±ce doñ informacje o zdarzeniach.
Nastêpnie, na ¿±danie, udostêpnia owe informacje zarejestrowanym
klientom.</p>

<p>Przyk³adowa realizacja sk³ada siê z nastêpuj±cych elementów:
<ul>
  <li><b>Notification</b> - interfejs definiuj±cy funkcjonalno¶æ serwera
  <li><b>NotificationServer</b> - serwer aplikacji utrzymuj±cy zbiór (kolejkê)
  zdarzeñ, dodaj±cy do tego zbioru nowe zdarzenia i udostêpniaj±cy owe
  zdarzenia klientom
  <li><b>Event</b> - klasa opisuj±ca pojedyncze zdarzenie, mo¿e zawieraæ
  dowolnie wybrane pola czy metody (<font class=title>uwaga:</font> obiekty
  tej klasy bêd± przekazywane poprzez zdalne po³±czenie RMI)
  <li><b>EventGenerator</b> - typ klienta, który <i>tworzy</i> nowe
  zdarzenia i rejestruje je w serwerze
  <li><b>EventMonitor</b> - typ klienta, który pobiera instniej±ce zdarzenia
  z serwera (i, dla przyk³adu, wypisuje je na <i>stdout</i>)
</ul>
</p>


<h2>Wskazówki i pomys³y</h2>

<p>
<ul>
  <li>Mo¿na dobraæ siê w dwie osoby i podzieliæ prac±!
  <li>Oba typy klientów mog± dzia³aæ <i>jednorazowo</i> lub te¿ w jakiego¶
  rodzaju pêtli (z udzia³em cz³oweka lub bez)
  <li>Klasa <b>Event</b> jest dobrym elementem do wykorzystania
  polimorfizmu - mo¿na spróbowaæ stworzyæ podklasy charakteryzuj±ce siê
  innym typem niesionej informacji (klasê bazow± mo¿na uczyniæ abstrakcyjn±
  lub zamieniæ j± na interfejs)
  <li>Serwer mo¿na wyposa¿yæ w ró¿ne kolejki zdarzeñ z ró¿nymi nazwami
  (tzw. <i>topic</i>) - wtedy monitory mog± pobieraæ tylko te zdarzenia,
  którymi s± zainteresowane
  <li>W RMI ³atwiej zaimplementowaæ model powiadamiania typu <i>pull</i>
  (klient sam zg³asza siê po wiadomo¶ci) - spróbowaæ zaimplementowaæ tak¿e
  model <i>push</i> (klient rejestruje siê w serwerze jako zainteresowany i
  jest automatycznie powiadamiany w chwili nadej¶cia wiadomo¶ci)
  <li>Czasem warto rozbiæ funkcjonalno¶æ takiego serwera na dwie czê¶ci
  (osobno przyjmowanie i publikowanie zdarzeñ) - dlaczego?
</uL>
</p>

<p>Metody i obiekty które mog± siê przydaæ:
<ul>
  <li>Thread.sleep(int) - u¶pienie (w milisekundach)
  <li>Calendar.getInstance().getTime() - czas
  <li>Calendar.getInstance().getTimeInMillis() - czas w [ms]
  <li>java.util - pakiet zawieraj±cy kolekcje obiektów
  <li>System.in.read() - czytanie z strumienia wej¶ciowego
</ul>
</p>
         

 
<hr>

<i>Tomasz Guba³a</i>

</body>
</html>
