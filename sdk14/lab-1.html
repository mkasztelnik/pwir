<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-2">
<link rel="stylesheet" type="text/css" href="style.css">
<title>Programowanie rozproszone w Javie - technologia RMI</title>
</head>


<body>

<h1>RMI - æwiczenie pierwsze</h1>

<B>Implementacja klienta i serwera Echo</b>

<p>Celem tego podstawowego æwiczenia jest zrozumienie sposobu
projektowania i implementacji prostych aplikacji dzia³aj±cych w oparciu
o technologiê <i>RMI</i>. Poszczególne punkty t³umacz± jak zaprojektowaæ
interfejs obiektu wywo³ywanego zdalnie, jak zaimplementowaæ
serwer tego obiektu oraz w jaki sposób ³±czyæ sie z tym serwerem z programu
klienta RMI.</p>



<h2>Definicja interfejsów</h2>

<p>Na pocz±tku definiujemy interfejs jakiego bêdzie u¿ywa³ serwer RMI.
Bêdzie to bardzo prosta aplikacja <i>odbijaj±ca</i> napis do nadawcy.</p>

<p>Metody, które mog± byæ wywo³ywane zdalnie, nale¿y zdefiniowaæ
w interfejsie dziedzicz±cym z interfejsu (rozszerzaj±cym
interfejs) <font class=title>java.rmi.Remote</font>. Co wiêcej, ka¿da z tych metod
musi zg³aszaæ wyj±tek <font class=title>java.rmi.RemoteException</font>
z uwagi na fakt, ¿e jej wywo³anie nastêpuje zdalnie.</p>

<p class=command>
public interface Echo extends <b>Remote</b> {<br>
&nbsp;&nbsp;String reply(String s) throws <b>RemoteException</b>;<br>
}
</p>

<p>Kompletny plik z definicj± interfejsu:
<a href="src/echo/Echo.java">Echo.java</a>.</p>



<h2>Implementacja serwera Echo</h2>

<p>
W czasie implementacji serwera w technologii RMI nale¿y pamiêtaæ
o nastêpuj±cych warunkach:
<ol>
<li>Klasa serwera musi implementowaæ zdefiniowany wy¿ej interfejs
oraz dziedziczyæ z klasy
<font class=title>java.rmi.server.UnicastRemoteObject</font>

<p class=command>
public class EchoServer extends <b>UnicastRemoteObject</b> implements Echo
</p>

<li>Konieczny jest konstruktor, nawet je¿eli nie wykonuje on niczego,
ze wzglêdu na wspomnian± deklaracjê zg³aszania wyj±tku

<p class=command>
public EchoServer() <b>throws RemoteException</b> {<br>
}
</p>

<li>Nastêpnie nale¿y zaimplementowaæ metodê zadeklarowan± w interfejsie.
Poniewa¿ ma byæ to <i>echo</i>, dlatego metoda po prostu zwraca bez zmian
to, co otrzyma³a jako argument. Aby potwierdzic fakt wywo³ania metody
wypisujemy komunikat

<p class=command>
public String reply(String s) {<br>
&nbsp;&nbsp;System.out.println("EchoServer: odebrana wiadomosc "+s);
&nbsp;&nbsp;return s;<br>
}
</p>

<li>Na pocz±tku metody <b>main()</b> musimy utworzyæ obiekt
<b>SecurityManager</b>, który bêdzie decydowa³, jakie uprawnienia
bêdzie mia³a aplikacja, która jest dostêpna z zewn±trz. W przypadku
RMI dobrze jest skorzystaæ z porêcznego
<font class=title>java.rmi.RMISecurityManager</font>

<p class=command>
public static void main(String[] args) {<br>
&nbsp;&nbsp;System.setSecurityManager(new RMISecurityManager());<br>
...
</p>

<li>Po utworzeniu obiektu serwera, musimy go wpisac do rejestru
(w Javie nazywanego <i>Naming Service</i>). Obiekt w rejestrze
zawsze figuruje pod pewn± nazw± - podajemy j± w tym wypadku w linii
poleceñ. Pod tak± nazw± klient bêdzie móg³ uzyskaæ referencjê do
obiektu serwera. Obiekt <font class=title>java.rmi.Naming</font>
w poni¿szym przyk³adzie jest obiektem statycznym i oznacza rejestr
znajduj±cy siê na tym samym komputerze, co aplikacja.

<p class=command>
String name = args[0];<br>
try {<br>
&nbsp;&nbsp;EchoServer server = new EchoServer();<br>
&nbsp;&nbsp;Naming.<b>rebind</b>(name, server);<br>
&nbsp;&nbsp;System.out.println("EchoServer: zarejestrowalem sie");<br>
} catch (Exception e) {<br>
&nbsp;&nbsp;System.err.println("EchoServer wyjatek: " + e.getMessage());<br>
&nbsp;&nbsp;e.printStackTrace();<br>
}
</p>            
</ol></p>

<p>Kompletny plik z implementacj± serwera Echo:
<a href="src/echo/EchoServer.java">EchoServer.java</a>.</p>



<h2>Implementacja klienta Echo</h2>

<p>W implementacji klienta trzeba wykonaæ nastêpuj±ce czynno¶ci:
<ol>
<li>Podobnie jak w przypadku serwera zaraz na pocz±tku metody <b>main()</b>
powo³ujemy do ¿ycia obiekt <b>RMISecurityManager</b>

<li>Wywo³ujemy metodê <b>lookup</b> aby uzyskaæ z rejestru referencjê
do obiektu serwera na podstawie nazwy (nazwê tê przekazujemy do programu
klienta tak¿e z linii komend). Metoda ta zwraca nam <i>zdaln± referencjê</i>
do obiektu serwera, któr± mo¿emy zrzutowaæ na interfejs <b>Echo</b> (gdy¿
wiemy ¿e serwer implementuje ten interfejs). Termin <i>zdalna referencja</i>
fizycznie oznacza zwyk³±, lokaln± referencjê, ale nie do samego obiektu
serwera (który wszak znajduje sie na odleg³ej maszynie) a do instancji <i>stub</i>
serwera. Jak wiemy, stub serwera musi implementowaæ ten sam interfejs <b>Echo</b>
(przez co rzutowanie jest mo¿liwe).

<p class=command>
String name = args[0];<br>
Echo echo = (Echo) Naming.<b>lookup</b>(name);
</p>

<li>Nastêpnie mo¿emy ju¿ wywo³aæ metodê <b>reply</b> tak, jak zwyk³±
metodê obiektu

<p class=command>
System.out.println(echo.reply(args[1]));
</p>            

</ol></p>

<p>Kompletny plik z implementacj± klienta Echo:
<a href="src/echo/EchoClient.java">EchoClient.java</a>.</p>



<h2>Kompilacja</h2>

<p>Zak³adamy, ¿e wszystkie pliki ¼ród³owe mamy w jednym katalogu,
np. /home/user/rmi/echo.
<ol>
<li>Kompilujemy wszystkie trzy pliki ¼ród³owe w zwyk³y sposób

<p class=command>
	javac *.java
</p>

<li>U¿ywamy polecenia <b>rmic</b> do wygenerowania stubu i skeletonu.
Polecenie to automatycznie wygeneruje pliki <b>EchoServer_Stub.java</b> oraz
<b>EchoServer_Skeleton.java</b> w tym samym katalogu a nastêpnie pliki te
skompiluje. Otrzymujemy <b>EchoServer_Stub.class</b> i
<b>EchoServer_Skeleton.class</b>. Je¿eli chcemy ogl±dn±æ pliki ¼ród³owe
generowane przez ten kompilator nale¿y u¿yæ opcji <b>-keep</b>.
<font class=title>Uwaga!</font> Nale¿y pamiêtaæ aby u¿yæ narzêdzia z tej
samej dystrybucji Java SDK z jakiej pochodzi u¿yty kompilator <b>javac</b>.

<p class=command>
	<strike>rmic EchoServer</strike><br>
	readlink javac<br>
	&nbsp;&nbsp;&nbsp;&nbsp;<b>/usr/java/j2sdk1.4.2_10/bin/</b>javac<br>
	/usr/java/j2sdk1.4.2_10/bin/rmic EchoServer
</p>

</ol></p>



<h2>Uruchamianie</h2>
<ol>
<li>Przed uruchmieniem serwera nale¿y zdefiniowaæ uprawnienia,
które bêd± przys³ugiwa³y aplikacji. Poniewa¿ aplikacja ta ma
korzystaæ z sieci, dlatego musi miec prawo do otwierania portów
(w szczególno¶ci portu <b>1099</b> którego domy¶lnie u¿ywa RMI).
Dodatkowo dostêpny port 80 (web server) bêdzie potrzebny przy kolejnych
æwiczeniach dotycz±cych dynamicznego pobierania klas z sieci.
Zapisujemy to w pliku <b><a href="src/echo/java.policy">java.policy</a></b>
w nastêpuj±cy sposób

<p class=command>
grant {<br>
&nbsp;&nbsp;permission java.net.SocketPermission "*:1024-65535", "connect,accept";<br>
&nbsp;&nbsp;permission java.net.SocketPermission "*:80", "connect";<br>
};
</p>

<li>W osobnym shellu uruchamiamy Naming Service (rejestr), poleceniem

<p class=command>
	<strike>rmiregistry</strike><br>
	readlink javac<br>
	&nbsp;&nbsp;&nbsp;&nbsp;<b>/usr/java/j2sdk1.4.2_10/bin/</b>javac<br>
	/usr/java/j2sdk1.4.2_10/bin/rmiregistry
</p>

Uwaga! Jezeli otrzymamy b³±d w rodzaju:

<b>java.rmi.server.ExportException: Port already in use: 1099</b>

oznacza to, ¿e rejestr jest ju¿ uruchomiony na tym komputerze
i nie trzeba go powtórnie uruchamiaæ.

<li>Uruchomienie serwera wykonujemy jako aplikacjê javy,
podaj±c dodatkowe opcje
<ul>
<li> <b>-Djava.rmi.server.codebase="URL"</b> wskazuje adres URL do miejsca,
gdzie znajduje siê <i>stub</i> obiektu serwera. Jest to informacja potrzebna
dla rejestru, aby móg³ przekazaæ klientom referencje do serwera.
URL mo¿e mieæ postaæ <i>"file: ..."</i>. W naszym wypadku powinien on wskazywaæ
na katalog bie¿±cy (<b>pwd</b>). W szczególno¶ci podawanie tej informacji
mo¿e nie byæ potrzebne, je¿eli rejestr RMI uruchomimy z tego samego
katalogu w którym znajduje siê klasa <b>EchoServer_Stub</b>
(lub katalog w którym ta klasa siê znajduje bêdzie wymieniony
w <i>CLASSPATH</i>). <font class=title>Uwaga!</font> Je¿eli URL
wskazuje na katalog, wówczas musi byæ zakoñczony znakiem <b>/</b>
<li> <b>-Djava.security.policy=java.policy</b> wskazuje plik z uprawnieniami. 
</ul>
Jako parametr wywo³ania podajemy równie¿ nazwê, pod jak± chcemy
zarejestrowaæ nasz obiekt w Name Service (np. echo123)

<p class=command>
java -Djava.rmi.server.codebase=file:`pwd`/  -Djava.security.policy=java.policy EchoServer echo123
</p>

<li>W osobnym terminalu (konsoli) wykonujemy aplikacjê klienta.
Przekazujemy jej dwa parametry: nazwê, pod jak± zarejestrowany jest
serwer oraz napis, który ma byæ przekazany do serwera Echo

<p class=command>
java -Djava.security.policy=java.policy  EchoClient echo123 HelloWorld!
</p>

Odpowied¼ powinna brzmieæ

<p class=command>
    HelloWorld!
</p>
</ol></p>



<h2>Zadanie</h2>

<p>Proszê dodaæ do serwera drug± metodê (np. dodawanie dwóch liczb)
i zaimplementowaæ odpowiedniego klienta.</p>



<hr>

<i>Tomasz Guba³a, Marek Kasztelnik</i>

</body>
</html>
