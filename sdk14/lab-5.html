<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-2">
<link rel="stylesheet" type="text/css" href="style.css">
<title>Programowanie rozproszone w Javie - technologia RMI</title>
</head>


<body>

         
<h1>RMI - æwiczenie pi±te</h1>
       
<h2>Przyk³ad aplikacji  - serwer z modu³ami typu <i>plug-in</i></h2>

<p>Przyk³adem ciekawszej aplikacji wykorzystuj±cej RMI oraz dynamiczne
³adowanie kodu jest serwer, do którego mo¿na dynamicznie ³adowaæ
<i>pluginy</i> i wykonywaæ w nich obliczenia na wirtualnej maszynie serwera.</p>

         
<h2>Interfejs Serializable</h2>

<p>Do tej pory korzystali¶my z interfejsu <font class=title>java.rmi.Remote</font>,
który umo¿liwia³ wywo³ywanie zdalnie metod na pewnym obiekcie.
Jako argumenty tych metod mog³y byæ u¿ywane wszystkie proste typy
jêzyka Java (<b>int</b>, <b>String</b> itp.), równie¿ ich tablice.
</p>

<p>¯eby móc przekazaæ jako parametr zdalnej metody dowolny obiekt,
musi on implementowaæ interfejs <font class=title>java.IO.Serializable</font>.
Wówczas obiekt ten jest przekazywany przez warto¶æ, czyli jego warto¶æ
jest kopiowana, serializowana (<i>marshalling</i>) i przesy³ana przez sieæ do
obiektu, który implementuje metodê (do serwera).
</p>

<p>Je¿eli parametrem zdalnej metody jest nie klasa, lecz interfejs, wówczas 
wirtualna maszyna, na której znajduje siê serwer, nie musi wcze¶niej znaæ 
definicji obiektu, który otrzyma w czasie dzia³ania od klienta. Wystarczy 
tylko, ¿e obiekt ten implementuje znany interfejs. Oznacza to, ¿e pliki
<b>.class</b> tego obiektu mog± nie byæ dostêpne w momencie uruchomienia
serwera. ¯eby klient móg³ przekazaæ obiekt nie znany wcze¶niej w wirtualnej
maszynie serwera, musi on podaæ lokalizacjê, sk±d mo¿na definicjê obiektu
pobraæ. W tym celu ponownie u¿ywamy opcji
</p>
     
<p class=command>java.rmi.server.codebase=&lt;URL&gt;</p>

Gdzie <b>&lt;URL&gt;</b> wskazuje na miejsce, z którego mo¿na pobraæ pliki
<b>.class</b>. W szczególno¶ci mo¿emy skorzystaæ z protoko³u HTTP aby pobraæ
pliki poprzez sieæ.
</p>



<h2>Aplikacja</h2>
<a href="plugin.gif">Prosty diagram klas aplikacji.</a>

<p>Potrzebne bêd± nastêpuj±ce pliki
   
<ul>
<!--    <li><a href="src/plug/AppContainer.java"><b>AppContainer.java</b></a>
    - definicja interfejsu serwera - kontenera dla pluginów
-->
	<li><b>AppContainer.java</b> - definicja interfejsu serwera -
	kontenera dla pluginów
    <li><a href="src/plug/Plugin.java"><b>Plugin.java</b></a>
    - definicja interfejsu pluginu
<!--    <li><a href="src/plug/AppServer.java"><b>AppServer.java</b></a>
    - implementacja serwera
-->
	<li><b>AppServer.java</b> - implementacja serwera
    <li><a href="src/plug/FibPlugin.java"><b>FibPlugin.java</b></a>
    - implementacja przyk³adowego pluginu licz±cego ci±g Fibonacciego
<!--    <li><a href="src/plug/AppClient.java"><b>AppClient.java</b></a>
    - implementacja klienta
-->
	<li><b>AppClient.java</b> - implementacja klienta
    <li>I dobrze znany <a href="src/echo/java.policy"><b>java.policy</b></a>
</ul></p>

<p>Wskazówki przy implementacji klienta:
<ol>
	<li>Utworzyæ obiekt klasy <b>FibPlugin</b> przekazuj±c do konstruktora
	numer ¿±danego wyrazu ci±gu Fibonacciego
	<li>Znale¼æ serwer w rejestrze <i>Naming Service</i>
	<li>Wywo³aæ metodê <b>run</b> serwera przekazuj±c utworzony obiekt
	pluginu jako parametr wywo³ania
</ol></p>

<p>Wskazówki przy implementacji serwera:
<ol>
	<li>Metoda <b>main</b> - podobna jak poprzednio
	<li>W metodzie <b>run</B> wywo³aæ metodê <b>compute</b> otrzymanego
	Pluginu i wynik jej dzia³ania zwróciæ klientowi
</ol></p>
	

<p>Pliki nale¿y skompilowaæ i utworzyæ <i>stub</i> dla klasy
<b>AppServer</b>.</p>



<h2>Uruchomienie przyk³adu</h2>

<p>Nale¿y przetestowaæ dzia³anie programów na dwóch ró¿nych komputerach.
   
<ol>
<li>Na komputerze A dzia³a <b>rmiregistry</b> oraz w osobnym katalogu 
znajduj± siê pliki serwera:
      <ul>
      <li><b>AppContainer.class</b>
      <li><b>AppServer_Stub.class</b>
      <li><b>java.policy</b>
      <li><b>AppServer.class</b>
      <li><b>Plugin.class</b>
      </ul>

<li>Pliki 
	<ul>
	<li><b>AppServer_Stub.class</b>
	<li><b>Plugin.class</b>
	<li><b>AppContainer.class</b>
	</ul>
nale¿y umie¶ciæ w katalogu <b>~/../pub/server_classes</b>
i ustawiæ odpowiednie prawa dostêpu (chmod a+r *). Wówczas <i>codebase</i> dla 
serwera bêdzie mieæ postaæ:
<b>http://artemis.wszib.edu.pl/~userA/server_classes</b>

<li>Nale¿y uruchomiæ serwer na komputerze A poleceniem

<p class=command>
java -Djava.rmi.server.codebase="http://artemis.wszib.edu.pl/~userA/server_classes/"
-Djava.security.policy=java.policy AppServer //hostA/appserver
</p>
gdzie <b>hostA</b> to nazwa domenowa komputera A

<li>Na komputerze B musz± byæ pliki klienta
	<ul>
	<li><b>AppClient.class</b>
	<li><b>AppContainer.class</b>
	<li><b>FibPlugin.class</b>
	<li><b>Plugin.class</b>
	<li><b>java.policy</b>
	</ul>
	
<li> Plik <b>FibPlugin.class</b> nale¿y umie¶ciæ w katalogu
<b>~/../pub/client_classes</b> i ustawiæ odpowiednie prawa dostêpu.
Wówczas <i>codebase</i> dla klienta bêdzie mieæ postaæ
<b>http://artemis.wszib.edu.pl/~userB/client_classes</b>

<li>Uruchomiæ na komputerze B klienta poleceniem
<p class=command>
java -Djava.rmi.server.codebase="http://artemis.wszib.edu.pl/~userB/client_classes/"
-Djava.security.policy=java.policy AppClient //hostA/appserver 8
</p>
To polecenie powinno zwróciæ ósmy wyraz ci±gu Fibonacciego.
   
</ol>


<h2>Zadanie</h2>
Proszê wymy¶liæ i napisaæ nowy plugin do tego serwera, który bêdzie
wykonywa³ inn± operacjê ni¿ <b>FibPlugin</b>. Ile plików trzeba
zmieniæ i rekompilowaæ?<br>

 
<hr>

<i>Tomasz Guba³a</i>

</body>
</html>
