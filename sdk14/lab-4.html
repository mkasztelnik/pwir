<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-2">
<link rel="stylesheet" type="text/css" href="style.css">
<title>Programowanie rozproszone w Javie - technologia RMI</title>
</head>


<body>

<h1>RMI - æwiczenie czwarte</h1>

<B>Automatyczna aktywacja serwera Echo <i>na ¿±danie</i></b>

<p>Jedn± z wad podstawowego zestawienia aplikacji
w technologii RMI jest konieczno¶æ utrzymywania procesu (JVM)
serwera aplikacji w ci±g³ym czynnym oczekiwaniu. Serwer taki dzia³a
bez wzglêdu na istnienie zapotrzebowania.</p>

<p>Jedn± z nowszych modyfikacji technologii RMI jest dodanie
mo¿liwo¶ci automatycznej aktywacji obiektu serwera kiedy zajdzie
taka potrzeba (tj. kiedy pojawi siê klient chc±cy wywo³aæ metodê
serwera).</p>

<p>Celem tego æwiczenia jest taka modyfikacja znanego serwera Echo
aby móg³ on korzystaæ z nowej w³a¶ciwo¶ci RMI.</p>


<h2>Konieczne zmiany</h2>

<p>W æwiczeniu wykorzystane bêd± pliki ¼ród³owe znane z æwiczeia
pierwszego. Plik ¼ród³owy serwera bêdzie musia³ ulec modyfikacjom,
pozosta³e pliki pozostaj± niezmienione. Mo¿na je pobraæ poni¿ej:
<ul>
  <li><a href="src/echo/Echo.java">Echo.java</a>
  <li><a href="src/echo/EchoClient.java">EchoClient.java</a>
  <li><a href="src/echo/java.policy">java.policy</a>
</ul>
Je¿eli kto¶ nadal dysponuje skompilowanym kodem interfejsu
(plik <b>Echo.class</b>) oraz klasy klienta (plik <b>EchoClient.class</b>)
mo¿e ich u¿yæ bez konieczno¶ci rekompilacji.
</p>


<h2>Modyfikacja klasy serwera</h2>

<p>Aby serwer echo by³ w stanie wykorzystaæ technologiê
<i>rmi.activation</i> musi rozszerzaæ klasê
<font class=title>java.rmi.activation.Activatable</font></p>

<p class=command>
public class ActiveEchoServer extends <b>Activatable</b>
implements Echo
</p>


<p>Modyfikacji musi tak¿e ulec konstruktor: tym razem posiada dwa
parametry wywo³ania. Pierwszym jest identyfikator obiektu
aktywowanego, drugi parametr s³u¿y do przekazania dodatkowych
informacji do tworzonego obiektu serwera (serwer echo jest na
tyle prosty ¿e nie potrzebujemy ¿adnych dodatkowych obiektów)</p>

<p class=command>
public ActiveEchoServer() (<b>ActivationID id</b>, MarshalledObject data)<br>
&nbsp;&nbsp;throws RemoteException {<br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>super(id, 0);</b><br>
}
</p>

<p>Implementacja metody <b>reply</b> pozostaje bez zmian.</p>



<h2>Implementacja kodu <i>setup</i></h2>

<p>Najwa¿niejsz± ró¿nic± wzglêdem wcze¶niejszej wersji serwera echo
jest kod który dokonuje samej operacji zarejestrowania klasy
serwera w demonie <b>rmid</b> oraz okre¶lenia warunków w których
przysz³a aktywacja serwera ma nast±piæ. Kod ten umie¶cimy w
metodzie <b>main</b> serwera, modyfikuj±c poprzedni± jej wersjê.</p>

<ol>

<li>Demon <b>rmid</b> grupuje zarejestrowane klasy w <i>grupy</i>.
Wszystkie obiekty z danej grupy s± aktywowane w obrêbie tej samej JVM
oraz na tych samych warunkach. Dlatego musimy stworzyæ tak± grupê.
W pierwszej kolejno¶ci opisujemy warunki aktywacji naszego serwera

<p class=command>
Properties prop = new Properties();<br>
prop.put("<b>java.security.policy</b>", "<b>java.policy</b>");<br>
<b>ActivationGroupDesc</b> grp = new ActivationGroupDesc(prop, null);
</p>

<p>W tym wypadku upewniamy siê, ¿e aktywowany obiekt serwera otrzyma
jako parametr odpowiedni plik z uprawnieniami (znany ju¿ nam z poprzednich
æwiczeñ).</p>


<li>Utworzenie grupy nastêpuje poprzez zarejestrowanie jej w systemie
<i>Activation</i> poprzez statyczn± metodê klasy 
<font class=title>java.rmi.activation.ActivationGroup</font>

<p class=command>
ActivationGroupID agid = ActivationGroup.getSystem().<B>registerGroup(grp)</b>;
</p>


<li>Nastêpnie w obrêbie stworzonej grupy tworzymy opis wywo³ania
naszego serwera echo (m.in. wskazuj±c gdzie znajduje siê skompilowany
kod oraz jak nazywa siê klasa serwera). Tak stworzony opis rejestrujemy
równie¿ otrzymuj±c w zamian referencjê do stworzonej instancji <i>stub</i>
serwera - instancjê tê mo¿emy z kolei zarejestrowaæ w rejestrze
<b>rmiregistry</b> gdzie bêdzie go móg³ znale¼æ klient

<p class=command>
ActivationDesc desc = new ActivationDesc<br>
&nbsp;&nbsp;(<b>agid</b>, "<b>ActiveEchoServer</b>", args[0], null);<br>
Echo server = (Echo) Activatable.<b>register</b>(desc);
</p>            
</ol></p>

<p>Kompletny plik z implementacj± nowego serwera Echo:
<a href="src/active/ActiveEchoServer.java">ActiveEchoServer.java</a>.</p>



<h2>Kompilacja</h2>

<p>
<ol>
<li>Je¿eli mamy gotowe pliki klas interfejsu i klienta, kompilujemy
sam nowy plik ¼ród³owy

<p class=command>
	javac ActiveEchoServer.java
</p>

Je¿eli nie, kompilujemy wszystkie trzy pliki ¼ród³owe jak poprzednio

<p class=command>
	javac *.java
</p>


<li>Generujemy nowy <i>stub</i> i <i>skeleton</i>.
<font class=title>Uwaga!</font> Nale¿y pamiêtaæ aby u¿yæ narzêdzia z tej
samej dystrybucji Java SDK z jakiej pochodzi u¿yty kompilator <b>javac</b>.

<p class=command>
	<strike>rmic ActiveEchoServer</strike><br>
	readlink javac<br>
	&nbsp;&nbsp;&nbsp;&nbsp;<b>/usr/java/j2sdk1.4.2_10/bin/</b>javac<br>
	/usr/java/j2sdk1.4.2_10/bin/rmic ActiveEchoServer
</p>

</ol></p>



<h2>Uruchamianie</h2>
<ol>
<li>Wykorzystamy poznany wcze¶niej mechanizm dynamicznego ³adowania klas -
skopiujmy pliki <b>ActiveEchoServer_Stub.class</b> i <b>Echo.class</b> do
katalogu który jest udostêpniany przez Web Server (czyli <i>~/../pub/</i>)

<li>Tak jak poprzednio, aby zmusiæ rejestr do pobierania pliku <i>Stub</i>
serwera poprzez sieæ uruchamiamy go w <b>innym</b> katalogu ni¿ lokalizacja
serwera Echo. Najlepiej uruchomiæ rejestr w tle poleceniem

<p class=command>
	<strike>rmiregistry</strike><br>
readlink javac<br>
	&nbsp;&nbsp;&nbsp;&nbsp;<b>/usr/java/j2sdk1.4.2_10/bin/</b>javac<br>
	/usr/java/j2sdk1.4.2_10/bin/rmiregistry &amp;
</p>


<li>Za poprawne dzia³anie mechanizmu <i>Activation</i> odpowiada
specjalny demon <b>rmid</b>. Musimy go uruchomiæ wskazuj±c odpowiedni
poziom uprawnieñ na jakim ma uruchamiaæ instancje serwera

<p class=command>
rmid -J-Dsun.rmi.activation.<b>execPolicy</b>=none &amp;
</p>

<p>Z kolei ten demon domy¶lnie nas³uchuje na porcie <b>1098</b>.</p>


<li>Uruchamiamy kod <i>setup</i> z klasy serwera w celu zestawienia
¶rodowiska w którym ma dzia³aæ serwer. Podajemy znan± opcjê z nazw±
pliku z opisem przyznanych uprawnieñ <b>java.policy</b>.
Jako pierwszy parametr wywo³ania tym razem przekazujemy lokalizacjê
skompilowanego kodu serwera. Drugim parametrem jest nazwa pod któr±
zarestrujemy siê w <b>rmiregistry</b> (pamiêtajmy aby przed tym
poleceniem znów znale¼æ siê w katalogu z plikami serwera)

<p class=command>
java -Djava.rmi.server.codebase="http://artemis.wszib.edu.pl/~userlogin/"
-Djava.security.policy=java.policy ActiveEchoServer
http://artemis.wszib.edu.pl/~userlogin/ //komp0101/echoserver
</p>


<li>Uruchomienie klienta nastêpuje w znany ju¿ sposób

<p class=command>
java -Djava.security.policy=java.policy EchoClient //komp0101/echoserver Hi
</p>

</ol></p>



<hr>

<i>Tomasz Guba³a, Marek Kasztelnik</i>

</body>
</html>
